"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientsService = void 0;
const common_1 = require("@nestjs/common");
const influx_buckets_service_1 = require("../influx-buckets/influx-buckets.service");
const influx_connections_service_1 = require("../influx-connections/influx-connections.service");
const Role_1 = require("../auth/models/Role");
const clients_repository_1 = require("./clients.repository");
let ClientsService = class ClientsService {
    constructor(clientsRepository, influxConnectionsService, influxBucketsService) {
        this.clientsRepository = clientsRepository;
        this.influxConnectionsService = influxConnectionsService;
        this.influxBucketsService = influxBucketsService;
    }
    async create(createClientDto, user) {
        if (user.accessLevel === Role_1.Role.ADMIN) {
            createClientDto.parentId = user.clientId;
        }
        const response = await this.clientsRepository.create(createClientDto);
        if (user.accessLevel === Role_1.Role.ADMIN) {
            const influxConnection = await this.influxConnectionsService
                .findAll()
                .exec();
            const searchRegExp = /\s/g;
            const bucket = {
                influxConnectionId: influxConnection[0]._id.toString(),
                clientId: response._id.toString(),
                alias: `Autogenerated ${createClientDto.name} bucket`,
                product: 'smart-trafo',
                name: `${createClientDto.name}-smart-trafo`
                    .replace(searchRegExp, '-')
                    .toLowerCase(),
            };
            this.influxBucketsService.create(bucket);
        }
        return response;
    }
    findAll() {
        return this.clientsRepository.find({});
    }
    async findWhere(whereClause) {
        return this.clientsRepository.find(whereClause);
    }
    findOne(id, projection) {
        return this.clientsRepository.findOne({ _id: id }, projection);
    }
    update(id, updateClientDto) {
        return this.clientsRepository.findOneAndUpdate({ _id: id }, updateClientDto);
    }
    remove(id) {
        return this.clientsRepository.delete(id);
    }
};
ClientsService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [clients_repository_1.ClientsRepository,
        influx_connections_service_1.InfluxConnectionsService,
        influx_buckets_service_1.InfluxBucketsService])
], ClientsService);
exports.ClientsService = ClientsService;
//# sourceMappingURL=clients.service.js.map